# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, Pants project contributors
# This file is distributed under the same license as the pex package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pex 2.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-03-31 14:28+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../docs/recipes.rst:4
msgid "PEX Recipes and Notes"
msgstr ""

#: ../../docs/recipes.rst:7
msgid "Long running PEX applications and daemons"
msgstr ""

#: ../../docs/recipes.rst:9
msgid ""
"If your PEXed application will run a long time, at some point you'll "
"likely need to debug or otherwise inspect it using operating system "
"tools. Unless you built your application as a non-``--venv`` ``--layout "
"loose`` PEX, its final process information will be inscrutable in ``ps`` "
"output since all other PEX forms re-execute themselves against an "
"installed version of themselves in the configured ``PEX_ROOT``."
msgstr ""

#: ../../docs/recipes.rst:15
msgid "You'll see something like this as a result:"
msgstr ""

#: ../../docs/recipes.rst:23
msgid ""
"The original PEX file is not mentioned anywhere in the ``ps`` output. "
"Worse, if you have many PEX processes it will be unclear which process "
"corresponds to which PEX."
msgstr ""

#: ../../docs/recipes.rst:26
msgid ""
"To remedy this, simply add `setproctitle "
"<https://pypi.org/project/setproctitle/>`_ as a dependency for your PEX. "
"The PEX runtime will then detect the presence of ``setproctitle`` and "
"alter the process title so you see both the Python being used to run your"
" PEX and the PEX file being run:"
msgstr ""

#: ../../docs/recipes.rst:37
msgid "PEX app in a container"
msgstr ""

#: ../../docs/recipes.rst:39
msgid ""
"If you want to use a PEX application in a container, you can get the "
"smallest container footprint and the lowest latency application start-up "
"by installing it with the ``venv`` Pex tool. First make sure you build "
"the pex with ``--include-tools`` (or ``--venv``), and then install it in "
"the container like so:"
msgstr ""

#: ../../docs/recipes.rst:59
msgid ""
"Here, the first two ``FROM`` images are illustrative. The only "
"requirement is they need to contain the Python interpreter your app "
"should be run with (``/usr/local/bin/python3.10`` in this example)."
msgstr ""

#: ../../docs/recipes.rst:62
msgid "The Pex ``venv`` tool will:"
msgstr ""

#: ../../docs/recipes.rst:64
msgid ""
"Install the PEX as a traditional venv at ``/my-app`` with a script at "
"``/my-app/pex`` that runs just like the original PEX."
msgstr ""

#: ../../docs/recipes.rst:66
msgid "Pre-compile all PEX Python code installed in the venv."
msgstr ""

#: ../../docs/recipes.rst:68
msgid ""
"Notably, the PEX venv install is done using a `multi-stage build "
"<https://docs.docker.com/develop/develop-images/multistage-build/>`_ to "
"ensure only the final venv remains on disk and it uses two layers to "
"ensure changes to application code do not lead to re-builds of lower "
"layers. This accommodates the common case of modifying and re-deploying "
"first party code more often than third party dependencies."
msgstr ""

#: ../../docs/recipes.rst:75
msgid "PEX-aware application"
msgstr ""

#: ../../docs/recipes.rst:77
msgid ""
"If your code benefits from knowing whether it is running from within a "
"PEX or not, you can inspect the ``PEX`` environment variable. If it is "
"set, it will be the absolute path of the PEX your code is running in. "
"Normally this will be a PEX zip file, but it could be a directory path if"
" the PEX was built with a ``--layout`` of ``packed`` or ``loose``."
msgstr ""

#: ../../docs/recipes.rst:83
msgid "Gunicorn and PEX"
msgstr ""

#: ../../docs/recipes.rst:85
msgid ""
"Normally, to run a wsgi-compatible application with Gunicorn, you'd just "
"point Gunicorn at your application, tell Gunicorn how to run it, and "
"you're ready to go - but if your application is shipping as a PEX file, "
"you'll have to bundle Gunicorn as a dependency and set Gunicorn as your "
"entry point. Gunicorn can't enter a PEX file to retrieve the wsgi "
"instance, but that doesn't prevent the PEX from invoking Gunicorn."
msgstr ""

#: ../../docs/recipes.rst:92
msgid ""
"This retains the benefit of zero `pip install`'s to run your service, but"
" it requires a bit more setup as you must ensure Gunicorn is packaged as "
"a dependency. The following snippets assume Flask as the wsgi framework, "
"Django setup should be similar:"
msgstr ""

#: ../../docs/recipes.rst:101
msgid ""
"Once your pex file is created, you need to make sure to pass your wsgi "
"app instance name to the CLI at runtime for Gunicorn to know how to hook "
"into it, configuration can be passed in the same way:"
msgstr ""

#: ../../docs/recipes.rst:109
msgid "And there you have it, a fully portable python web service."
msgstr ""

#: ../../docs/recipes.rst:112
msgid "PEX and Proxy settings"
msgstr ""

#: ../../docs/recipes.rst:114
msgid ""
"While building pex files, you may need to fetch dependencies through a "
"proxy. The easiest way is to use pex cli with the requests extra and "
"environment variables. Following are the steps to do just that:"
msgstr ""

#: ../../docs/recipes.rst:116
msgid "Install pex with requests"
msgstr ""

#: ../../docs/recipes.rst:122
msgid "Set the environment variables"
msgstr ""

#: ../../docs/recipes.rst:130
msgid "Now you can test by running"
msgstr ""

#: ../../docs/recipes.rst:136
msgid ""
"For more information on the requests module support for proxies via "
"environment variables, see the official documentation here: http://docs"
".python-requests.org/en/master/user/advanced/#proxies."
msgstr ""

